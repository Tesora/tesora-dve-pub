// OS_STATUS: public
package com.tesora.dve.db.mysql;

/*
 * #%L
 * Tesora Inc.
 * Database Virtualization Engine
 * %%
 * Copyright (C) 2011 - 2014 Tesora Inc.
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * #L%
 */

import com.tesora.dve.charset.NativeCharSet;
import com.tesora.dve.charset.mysql.MysqlNativeCharSetCatalog;
import com.tesora.dve.db.NativeTypeCatalog;
import com.tesora.dve.db.mysql.libmy.MyFieldPktResponse;
import com.tesora.dve.exceptions.PECodingException;
import com.tesora.dve.exceptions.PEException;
import com.tesora.dve.resultset.ColumnMetadata;
import com.tesora.dve.server.global.HostService;
import com.tesora.dve.singleton.Singletons;

/**
 * Utility calls to convert between ColumnMetadata and mysql column definition packets.  This logic was originally in MSPFieldResponse,
 * but that tied the class to native charset catalog resources that are currently difficult to separate from the core processing classes.  Also,
 * MSPFieldResponse was very similar to MyFieldPktResponse, except for additional ColumnMetadata processing.  By moving the ColumnMetadata
 * logic here, MSPFieldResponse and MyFieldPktResponse could get merged into one class (MyFieldPktResponse), and that class
 * is independent of the core processing classes.
 */
public class FieldMetadataAdapter {
    private static final int CHARSET_BINARY = 63;

    /**
     * Constructs an outbound column metadata packet given an existing ColumnMetadata object.
     * @param columnMetadata
     * @param nativeTypeCatalog
     * @param nativeCharSet
     * @return
     * @throws PEException
     */
    public static MyFieldPktResponse buildPacket(ColumnMetadata columnMetadata, NativeTypeCatalog nativeTypeCatalog, NativeCharSet nativeCharSet) throws PEException {
        MyFieldPktResponse fieldPkt = new MyFieldPktResponse();
        fieldPkt.setPacketNumber((byte)0);
        fieldPkt.setCatalog("def");

        if (columnMetadata.getTableName() == null) {
            fieldPkt.setDatabase("");
            fieldPkt.setTable("");
            fieldPkt.setOrig_table("");
        } else {
            fieldPkt.setDatabase(columnMetadata.getDbName());
            fieldPkt.setTable(columnMetadata.getTableName());
            fieldPkt.setOrig_table(columnMetadata.getTableName());
        }

        fieldPkt.setColumn(columnMetadata.getQueryName());
        fieldPkt.setOrig_column(columnMetadata.getName());

        MysqlNativeType colNativeType = (MysqlNativeType) nativeTypeCatalog.findType(columnMetadata.getNativeTypeName(), true);
        fieldPkt.setCharset(colNativeType.getCharSet());

        short flags = colNativeType.getFieldTypeFlags();
        if (MysqlNativeTypeUtils.isUnsigned(columnMetadata, colNativeType))
            flags = MysqlNativeConstants.FLDPKT_FLAG_UNSIGNED;
        MyFieldType fieldType = MyFieldType.mapFromNativeType(columnMetadata.getNativeTypeName());
        flags += (columnMetadata.isKeyPart() ? MysqlNativeConstants.FLDPKT_FLAG_PART_KEY : 0);
        flags += (columnMetadata.isUniqueKey() ? MysqlNativeConstants.FLDPKT_FLAG_UNIQUE_KEY : 0);
        flags += (columnMetadata.isNonUniqueKey() ? MysqlNativeConstants.FLDPKT_FLAG_MULTIPLE_KEY : 0);
        flags += (columnMetadata.isPrimaryKey() ? MysqlNativeConstants.FLDPKT_FLAG_PRI_KEY : 0);
        flags += (columnMetadata.isAutoGenerated() ? MysqlNativeConstants.FLDPKT_FLAG_AUTO_INCREMENT : 0);
        flags += (columnMetadata.isNullable() ? 0 : MysqlNativeConstants.FLDPKT_FLAG_NOT_NULL);


        int maxLen = 1;
        if (colNativeType.isStringType()) {
            maxLen = (nativeCharSet != null) ? (int) nativeCharSet.getMaxLen() : 1;
        }

        int columnMetadataSize = columnMetadata.getSize();
        int columnMetadataScale = columnMetadata.getScale();

        fieldPkt.setColumn_length(columnMetadataSize * maxLen);
        fieldPkt.setColumn_type(fieldType);
        fieldPkt.setFlags(flags);
        fieldPkt.setScale(columnMetadataScale);

        return fieldPkt;
    }

    /**
     * Constructs a ColumnMetadata object given an inbound column metadata packet.  The constructed metadata object needs
     * the column name, which requires an expensive unpacking of the field packet.
     * @param columnDefPacket
     * @return
     */
    public static ColumnMetadata buildMetadata(MyFieldPktResponse columnDefPacket) {
        int maxDataLen = columnDefPacket.getColumn_length();
        if (maxDataLen < 0)  //TODO: mysql length is 32 bits, unsigned, but we use 32 bits signed.  This is a workaround until we deal with lengths greater than Integer.MAX_VALUE.
            maxDataLen = Integer.MAX_VALUE;
        byte charSet = columnDefPacket.getCharset();
        short flags = columnDefPacket.getFlags();
        if (charSet != CHARSET_BINARY && (flags & MysqlNativeConstants.FLDPKT_FLAG_BINARY) == 0) {
            // charSet 63 is Binary - ugly, but I'm not sure what else to do here /mwj
            NativeCharSet cs = MysqlNativeCharSetCatalog.DEFAULT_CATALOG.findNativeCharsetById(charSet);
            if (cs == null)
                throw new PECodingException("Column definition gets unsupported character set (" + charSet + ")");
            maxDataLen /= cs.getMaxLen();
        }

        MyFieldType fieldType = columnDefPacket.getColumn_type();
        MysqlNativeType mnt;
        try {
            mnt = ((MysqlNative) Singletons.require(HostService.class).getDBNative()).getNativeTypeFromMyFieldType(fieldType, flags, maxDataLen);
        } catch (PEException e) {
            throw new PECodingException("Couldn't lookup native type", e);
        }
        if (mnt == null)
            throw new PECodingException("Unsupported native type " + fieldType);

        ColumnMetadata columnMetadata = new ColumnMetadata(columnDefPacket.getOrig_column(), maxDataLen, mnt.getTypeName(), mnt.getDataType(), false /* requiresFix */);
        columnMetadata.setNativeTypeId(fieldType.getByteValue());
        columnMetadata.setAliasName(columnDefPacket.getColumn());
        columnMetadata.setDbName(columnDefPacket.getDatabase());
        columnMetadata.setTableName(columnDefPacket.getTable());
        columnMetadata.setScale(columnDefPacket.getScale());
        if ( mnt.isDecimalType() )
            columnMetadata.setPrecision(MysqlNativeConstants.MAX_DECIMAL_PRECISION);

        columnMetadata.setNativeTypeFlags(flags);
        columnMetadata.setAutoGenerated((flags & MysqlNativeConstants.FLDPKT_FLAG_AUTO_INCREMENT) > 0);
        columnMetadata.setNullable((flags & MysqlNativeConstants.FLDPKT_FLAG_NOT_NULL) > 0);
        if ((flags & MysqlNativeConstants.FLDPKT_FLAG_UNIQUE_KEY) > 0)
            columnMetadata.uniqueKey();
        if ((flags & MysqlNativeConstants.FLDPKT_FLAG_MULTIPLE_KEY) > 0)
            columnMetadata.nonUniqueKey();
        if ((flags & MysqlNativeConstants.FLDPKT_FLAG_PRI_KEY) > 0)
            columnMetadata.primaryKey();

        if ( fieldType.supportsUnsigned() && (flags & MysqlNativeConstants.FLDPKT_FLAG_UNSIGNED) > 0 )
            columnMetadata.setNativeTypeModifiers(MysqlNativeType.MODIFIER_UNSIGNED);

        return columnMetadata;
    }

}
