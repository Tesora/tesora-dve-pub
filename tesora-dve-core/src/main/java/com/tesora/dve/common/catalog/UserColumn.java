package com.tesora.dve.common.catalog;

/*
 * #%L
 * Tesora Inc.
 * Database Virtualization Engine
 * %%
 * Copyright (C) 2011 - 2014 Tesora Inc.
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * #L%
 */


import java.sql.Types;
import java.util.Collections;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.Lob;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

import com.tesora.dve.server.global.HostService;
import com.tesora.dve.singleton.Singletons;

import org.hibernate.annotations.ForeignKey;
import org.apache.commons.lang.BooleanUtils;
import org.apache.commons.lang.StringUtils;

import com.tesora.dve.common.ShowSchema;
import com.tesora.dve.db.NativeType;
import com.tesora.dve.db.mysql.MysqlNativeType.MysqlType;
import com.tesora.dve.exceptions.PEException;
import com.tesora.dve.resultset.ColumnMetadata;
import com.tesora.dve.resultset.ColumnSet;
import com.tesora.dve.resultset.ResultRow;
import com.tesora.dve.sql.infoschema.annos.ColumnView;
import com.tesora.dve.sql.infoschema.annos.InfoSchemaColumn;
import com.tesora.dve.sql.infoschema.annos.InfoSchemaTable;
import com.tesora.dve.sql.infoschema.annos.InfoView;
import com.tesora.dve.sql.infoschema.annos.TableView;


/**
 * Entity implementation class for Entity: UserColumn
 *
 */
@InfoSchemaTable(logicalName="user_column",
		views={@TableView(view=InfoView.SHOW, name="column", pluralName="columns",
				columnOrder={ShowSchema.Column.NAME, 
							 ShowSchema.Column.TYPE, 
							 ShowSchema.Column.NULLABLE, 
							 ShowSchema.Column.KEY, 
							 ShowSchema.Column.DEFAULT, 
							 ShowSchema.Column.EXTRA,
							 "ordinal_position",
							 "table"}),
			   @TableView(view=InfoView.INFORMATION, name="columns", pluralName="",
				columnOrder={"table_name", "column_name", "ordinal_position", "column_default",
					   "is_nullable", "data_type", "character_maximum_length", 
					   "numeric_precision", "numeric_scale", 
					   "character_set_name", 
					   "collation_name", "column_type", "column_key",
					   "extra", "is_autogenerated", 
					   "java_sql_type", "native_type_name", "column_comment" })})
@Entity
@Table(name="user_column")
public class UserColumn implements CatalogEntity, PersistentColumn {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue
	@Column(name="user_column_id")
	private int id;
	
	@ForeignKey(name="fk_column_table")
	@ManyToOne
	@JoinColumn(name="user_table_id")
	private UserTable userTable;
	
	@Column(name="name",nullable=false)
	private String name;
	@Column(name="data_type",nullable=false)
	private int dataType;
	@Lob @Column(name="native_type_name",nullable=false)
	private String nativeTypeName;
	@Column(name="native_type_modifiers")
	private String nativeTypeModifiers;
	@Column(name="size", nullable=false)
	private int size = 0;
	@Column(name="hash_position")
	private int hashPosition = 0;
	@Column(name="prec", nullable=false)
	private int precision = 0;
	@Column(name="scale", nullable=false)
	private int scale = 0;
	@Column(name="nullable",nullable=false)
	private Boolean nullable = false;
	@Column(name="has_default_value",nullable=false)
	private Boolean hasDefault = false;
	@Column(name="default_value_is_constant",nullable=false)
	private int defaultValueIsConstant = 1;
	@Column(name="auto_generated",nullable=false)
	private Boolean autoGenerated = false;
	@Lob @Column(name="default_value")
	private String defaultValue = "";
	@Column(name = "order_in_table",nullable=false)
	private Integer orderInTable;
	@Column(name="on_update",nullable=false)
	private int onUpdate = 0;
	@Column(name="cdv")
	private int cdv_position = 0;
	@Column (name="comment",nullable=true)
	private String comment;
	@Column (name="charset",nullable=true)
	private String charset;
	@Column (name="collation",nullable=true)
	private String collation;

	private transient ColumnSet showColumnSet = null;
	private transient boolean nativeTypeSet = false;
	private transient byte nativeType;

	public UserColumn() {
	}   

	// Copy Constructor
	public UserColumn( UserColumn uc ) {
		this.copyFrom(uc);
	}   

	// Create a UserColumn entity from a ColumnMetadata object
	public UserColumn ( ColumnMetadata cm ) throws PEException {
        Singletons.require(HostService.class).getDBNative().convertColumnMetadataToUserColumn(cm, this);
	}
	
	public ColumnMetadata getColumnMetadata() {
		ColumnMetadata cm = new ColumnMetadata(name, dataType, nativeTypeName);
		cm.setAutoGenerated(autoGenerated);
		cm.setDefaultValue(defaultValue);
		cm.setDefaultValueIsConstant(BooleanUtils.toBooleanObject(defaultValueIsConstant));
		cm.setHasDefault(hasDefault);
		cm.setHashPosition(hashPosition);
		cm.setNativeTypeModifiers(nativeTypeModifiers);
		cm.setNullable(nullable);
		cm.setOnUpdate(BooleanUtils.toBooleanObject(onUpdate));
		cm.setOrderInTable(orderInTable);
		cm.setPrecision(precision);
		cm.setScale(scale);
		cm.setSize(size);
		if (getUserTable() != null)
			cm.setTableName(getUserTable().getName());

		return cm;
	}
	
	public UserColumn(UserTable ut, String name, int dataType, String nativeTypeName, int size) {
		this.name = name;
		this.dataType = dataType;
		this.setNativeTypeName(nativeTypeName);
		this.size = size;
		this.userTable = ut;
		ut.addUserColumn(this);
	}

	public UserColumn(UserTable ut, String name, int dataType, String nativeTypeName) {
		this.name = name;
		this.dataType = dataType;
		this.setNativeTypeName(nativeTypeName);
		this.userTable = ut;
		ut.addUserColumn(this);
	}

	public UserColumn(String name, int dataType, String nativeTypeName ) {
		this.name = name;
		this.dataType = dataType;
		this.setNativeTypeName(nativeTypeName);
	}

    public void copyFrom(UserColumn uc) {
        name = uc.name;
        dataType = uc.dataType;
        nativeTypeName = uc.nativeTypeName;
        nativeTypeModifiers = uc.nativeTypeModifiers;
        size = uc.size;
        userTable = uc.userTable;
        autoGenerated = uc.autoGenerated;
        defaultValue = uc.defaultValue;
        hasDefault = uc.hasDefault;
        defaultValueIsConstant = uc.defaultValueIsConstant;
        precision = uc.precision;
        scale = uc.scale;
        hashPosition = uc.hashPosition;
        nullable = uc.nullable;
        onUpdate = uc.onUpdate;
        comment = uc.comment;
    }

	@InfoSchemaColumn(logicalName="id",fieldName="id",
			sqlType=java.sql.Types.INTEGER,
			views={})	
	@Override
	public int getId() {
		return id;
	}

	@InfoSchemaColumn(logicalName="user_table", fieldName="userTable",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.INFORMATION,name="table_name",injected=true),
				   @ColumnView(view=InfoView.SHOW,name="table",visible=false,injected=true)},
			injected=true)
	public UserTable getUserTable() {
		return userTable;
	}
	public void setUserTable( UserTable userTable ) {
		this.userTable = userTable;
	}
	
	@InfoSchemaColumn(logicalName="name",fieldName="name",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.SHOW, name=ShowSchema.Column.NAME,ident=true),
			       @ColumnView(view=InfoView.INFORMATION, name="column_name", ident=true)})
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}   

	public String getNameAsIdentifier() {
        return Singletons.require(HostService.class).getDBNative().getNameForQuery(this);
	}
	
	public String getQueryName() {
		return getName();
	}

	public String getAliasName() {
		return getName();
	}
	
	@InfoSchemaColumn(logicalName="data_type",fieldName="dataType",
			sqlType=java.sql.Types.INTEGER,sqlWidth=10,
			views={@ColumnView(view=InfoView.INFORMATION, name="java_sql_type")})
	public int getDataType() {
		return dataType;
	}

	public void setDataType(int dataType) {
		this.dataType = dataType;
	}   
	
	@InfoSchemaColumn(logicalName="native_type_name_with_mod",fieldName="",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.INFORMATION, name="data_type")})
	public String getFullNativeTypeName() {
		if ( nativeTypeModifiers == null )
			return nativeTypeName;
		
		return nativeTypeName + " " + nativeTypeModifiers;
	}
	
	@InfoSchemaColumn(logicalName="native_type_name",fieldName="nativeTypeName",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.INFORMATION, name="native_type_name")})
	public String getNativeTypeName() {
		return nativeTypeName;
	}
	
	public void setNativeTypeName(String nativeTypeName) {
		this.nativeTypeName = NativeType.fixName(nativeTypeName);
	}
	
	public String getNativeTypeModifiers() {
		return nativeTypeModifiers;
	}

	public void setNativeTypeModifiers(String nativeTypeModifiers) {
		this.nativeTypeModifiers = (nativeTypeModifiers == null ? nativeTypeModifiers : NativeType.fixName(nativeTypeModifiers).trim());
	}

	@InfoSchemaColumn(logicalName="size", fieldName="size",
			sqlType=java.sql.Types.INTEGER,
			views={@ColumnView(view=InfoView.INFORMATION,name="character_maximum_length")})
	public int getSize() {
		return size;
	}

	public void setSize(int size) {
		this.size = size;
	}
	
	@InfoSchemaColumn(logicalName="hash_position",fieldName="hashPosition",
			sqlType=java.sql.Types.INTEGER,
			views={})
	public int getHashPosition() {
		return hashPosition;
	}

	public void setHashPosition(int hashPosition) {
		this.hashPosition = hashPosition;
	}   

	@InfoSchemaColumn(logicalName="precision", fieldName="precision",
			sqlType=java.sql.Types.INTEGER,
			views={@ColumnView(view=InfoView.INFORMATION,name="numeric_precision")})
	public int getPrecision() {
		return precision;
	}

	public void setPrecision(int precision) {
		this.precision = precision;
	}
	
	@InfoSchemaColumn(logicalName="scale", fieldName="scale",
			sqlType=java.sql.Types.INTEGER,
			views={@ColumnView(view=InfoView.INFORMATION,name="numeric_scale")})
	public int getScale() {
		return scale;
	}

	public void setScale(int scale) {
		this.scale = scale;
	}   
	public Boolean isNullable() {
		return getNullable();
	}

	@InfoSchemaColumn(logicalName="nullable", fieldName="nullable",
			sqlType=java.sql.Types.VARCHAR,
			views={@ColumnView(view=InfoView.SHOW,name=ShowSchema.Column.NULLABLE),
				   @ColumnView(view=InfoView.INFORMATION,name="is_nullable")})
	public Boolean getNullable() {
		return nullable;
	}

	public void setNullable(Boolean nullable) {
		this.nullable = nullable;
	}   
	
	public Boolean hasDefault() {
		return getHasDefault();
	}

	public Boolean getHasDefault() {
		return hasDefault;
	}

	public void setHasDefault(Boolean hasDefault) {
		this.hasDefault = hasDefault;
	}   

	public Boolean defaultValueIsConstant() {
		return BooleanUtils.toBooleanObject(defaultValueIsConstant);
	}
	
	public void setDefaultValueIsConstant(Boolean isConstant) {
		this.defaultValueIsConstant = BooleanUtils.toInteger(isConstant);
	}
	
	public Boolean isAutoGenerated() {
		return getAutoGenerated();
	}

	@InfoSchemaColumn(logicalName="autogenerated", fieldName="autoGenerated",
			sqlType=java.sql.Types.VARCHAR,
			views={@ColumnView(view=InfoView.INFORMATION,name="is_autogenerated")})
	public Boolean getAutoGenerated() {
		return autoGenerated;
	}
	
	public void setAutoGenerated(Boolean autoGenerated) {
		this.autoGenerated = autoGenerated;
	}

	@InfoSchemaColumn(logicalName="default", fieldName="", 
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.SHOW,name=ShowSchema.Column.DEFAULT),
				   @ColumnView(view=InfoView.INFORMATION,name="column_default")})
	public String getDefaultValue() {
		return this.hasDefault ? this.defaultValue : null;
	}

	public void setDefaultValue(String defaultValue) {
		this.defaultValue = defaultValue;
	}   
	
	@Override
	public boolean equals(Object o) {
		if ( this == o )
			return true;
		boolean isEqual = false;
		if (o instanceof UserColumn) {
			UserColumn oCol = (UserColumn)o;
			isEqual 
				= StringUtils.equals(userTable.getName(),oCol.userTable.getName())
				&& StringUtils.equals(userTable.getDatabase().getName(),oCol.userTable.getDatabase().getName())
				&& StringUtils.equals(name, oCol.name)
				&& dataType == oCol.dataType
				&& nativeTypeName.equals(oCol.nativeTypeName)
				&& size == oCol.size
				&& hashPosition == oCol.hashPosition
				&& precision == oCol.precision
				&& scale == oCol.scale
				&& nullable == oCol.nullable
				&& hasDefault == oCol.hasDefault
				&& defaultValueIsConstant == oCol.defaultValueIsConstant
				&& autoGenerated == oCol.autoGenerated
				&& StringUtils.equals(defaultValue, oCol.defaultValue)
				&& onUpdate == oCol.onUpdate
				&& cdv_position == oCol.cdv_position;
		}
		
		return isEqual;
	}
    
	@InfoSchemaColumn(logicalName="ordinal_position",fieldName="orderInTable",
			sqlType=java.sql.Types.INTEGER,sqlWidth=10,
			views={@ColumnView(view=InfoView.INFORMATION, name="ordinal_position", orderBy=true),
				   @ColumnView(view=InfoView.SHOW,name="ordinal_position",orderBy=true,visible=false)})
	public Integer getOrderInTable() {
		return orderInTable;
	}

	public void setOrderInTable(Integer orderInTable) {
		this.orderInTable = orderInTable;
	}

	// used for computing comparable dvs
	public boolean comparableType(UserColumn other) {
		return (dataType == other.dataType &&
				nativeTypeName.equals(other.nativeTypeName) &&
				precision == other.precision &&
				scale == other.scale &&
				size == other.size);
	}
	
	@Override
	public String toString()
	{
		return "Column ID: " + getId() + " Name: " + getName() + 
			" Type:" + getDataType() +
			" Native Type: " + getNativeTypeName() +
			" In Table: " + (userTable == null ? "Unknown" : getUserTable());
	}

	@Override
	public ColumnSet getShowColumnSet(CatalogQueryOptions cqo) {
		if ( showColumnSet == null ) {
			showColumnSet = new ColumnSet();
			showColumnSet.addColumn("Field", 255, "varchar", Types.VARCHAR);
			showColumnSet.addColumn("Type", 255, "varchar", Types.VARCHAR);
			showColumnSet.addColumn("Null",3,"varchar", Types.VARCHAR);
			showColumnSet.addColumn("Key",3,"varchar", Types.VARCHAR);
			showColumnSet.addColumn("Default",255,"varchar",Types.VARCHAR);
			showColumnSet.addColumn("Extra",255,"varchar",Types.VARCHAR);
		}
		return showColumnSet;
	}

	@Override
	public ResultRow getShowResultRow(CatalogQueryOptions cqo) throws PEException {
		ResultRow rr = new ResultRow();
		rr.addResultColumn(this.name, false);
        String type = Singletons.require(HostService.class).getDBNative().getDataTypeForQuery(this);
		rr.addResultColumn(type, false);
		rr.addResultColumn(this.nullable ? "YES" : "NO" );
		rr.addResultColumn(this.isPrimaryKeyPart()? "PRI" : "" );
		rr.addResultColumn(this.hasDefault ? this.defaultValue : "NULL");
		rr.addResultColumn(this.isAutoGenerated() ? "auto_increment" : "" );
				
		return rr;
	}

	@InfoSchemaColumn(logicalName="extra",fieldName="",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.SHOW,name=ShowSchema.Column.EXTRA),
				   @ColumnView(view=InfoView.INFORMATION,name="extra")})
	public String getShowExtra() {
		return (this.isAutoGenerated() ? "auto_increment" : "");
	}
	
	@InfoSchemaColumn(logicalName="type",fieldName="",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.SHOW,name=ShowSchema.Column.TYPE),
			       @ColumnView(view=InfoView.INFORMATION,name="column_type")})
	public String getShowType() throws PEException {
        return Singletons.require(HostService.class).getDBNative().getDataTypeForQuery(this);
	}

	@InfoSchemaColumn(logicalName="key", fieldName="",
			sqlType=java.sql.Types.VARCHAR,sqlWidth=3,
			views={@ColumnView(view=InfoView.SHOW,name=ShowSchema.Column.KEY),
				   @ColumnView(view=InfoView.INFORMATION,name="column_key")})
	public String getShowKey() {
		return (isPrimaryKeyPart() ? "PRI" : "");
	}

	
	public boolean isPrimaryKeyPart() {
		Key pk = userTable.getPrimaryKey();
		if (pk == null) return false;
		return pk.containsColumn(this);
	}
	
	@Override
	public void removeFromParent() throws Throwable {
		userTable.removeUserColumn(this);
	}
	
	@Override
	public List<CatalogEntity> getDependentEntities(CatalogDAO c) throws Throwable {
		// TODO Return a valid list of dependents
		return Collections.emptyList();
	}

	public Boolean hasOnUpdate() {
		return BooleanUtils.toBooleanObject(onUpdate);
	}
	
	public void setOnUpdate(Boolean onUpdateValue) {
		this.onUpdate = BooleanUtils.toInteger(onUpdateValue);
	}
	
	public int getCDV_Position() {
		return cdv_position;
	}

	public void setCDV_Position(int offset) {
		cdv_position = offset;
	}

	@InfoSchemaColumn(logicalName="column_comment", fieldName="comment", 
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={@ColumnView(view=InfoView.INFORMATION,name="column_comment")})
	public String getComment() {
		return comment;
	}
	
	public void setComment(String s) {
		comment = s;
	}
	
	public void setCollation(String s) {
		collation = s;
	}
	
	@InfoSchemaColumn(logicalName="column_collation", fieldName="collation", 
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={
			@ColumnView(view=InfoView.INFORMATION,name="collation_name")
			})	
	public String getCollation() {
		return collation;
	}
	
	public void setCharset(String s) {
		charset = s;
	}

	@InfoSchemaColumn(logicalName="column_charset", fieldName="charset", 
			sqlType=java.sql.Types.VARCHAR,sqlWidth=255,
			views={
			@ColumnView(view=InfoView.INFORMATION,name="character_set_name")
			})
	public String getCharset() {
		return charset;
	}
	
	@Override
	public void onUpdate() {
	}

	@Override
	public void onDrop() {
	}

	public byte getUserTypeByte() {
		if (!nativeTypeSet) {
			nativeType = MysqlType.toMysqlType(nativeTypeName).getMysqlFieldType().getByteValue();
		}
		return nativeType;
	}

	@Override
	public String getPersistentName() {
		return getName();
	}
}
